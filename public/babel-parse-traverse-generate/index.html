<!DOCTYPE html>
<html lang="jp">
  <head>
    <title>Babelã®å¤‰æ›å‡¦ç†ã¨å‘ãåˆã†</title>
    <meta charset="UTF-8" />
    <meta name="description" content="ãã†ã„ãˆã° Babel ã‚’ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ãŸã“ã¨ãªã‹ã£ãŸãªã¨æ€ã£ã¦ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ã¦ã¿ãŸã£ã¦è¨€ã†è©±ã§ã™ã€‚">
    <meta property="og:title" content="Babelã®å¤‰æ›å‡¦ç†ã¨å‘ãåˆã†">
    <meta property="og:image" content="https://blog.ojisan.io//babel-parse-traverse-generate/visual.png">
    <meta property="og:description" content="ãã†ã„ãˆã° Babel ã‚’ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ãŸã“ã¨ãªã‹ã£ãŸãªã¨æ€ã£ã¦ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ã¦ã¿ãŸã£ã¦è¨€ã†è©±ã§ã™ã€‚">
    <meta property="og:type" content="article">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@sadnessOjisan">
    <meta name="twitter:title" content="Babelã®å¤‰æ›å‡¦ç†ã¨å‘ãåˆã†">
    <meta name="twitter:description" content="ãã†ã„ãˆã° Babel ã‚’ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ãŸã“ã¨ãªã‹ã£ãŸãªã¨æ€ã£ã¦ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ã¦ã¿ãŸã£ã¦è¨€ã†è©±ã§ã™ã€‚">
    <link
      href="https://fonts.googleapis.com/css?family=M+PLUS+Rounded+1c"
      rel="stylesheet"
      id="webfont"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="https://fonts.googleapis.com/css?family=Inconsolata"
    />
    <!-- FYI: https://highlightjs.org/static/demo/ -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/nord.min.css"
    />
    <link rel="stylesheet" href="../post.css" />
    <link rel="stylesheet" href="../reset.css" />
  </head>
  <body>
    <header>
      <a href="/">
        <span class="title">blog.ojisan.io</span>
      </a>
    </header>
    <div class="post-head">
      <img src="visual.png" class="key_visual"></img>
      <time>2020-06-12</time>
      <h1>Babelã®å¤‰æ›å‡¦ç†ã¨å‘ãåˆã†</h1>
    </div>
    <div class="post-contents"><p>ãã†ã„ãˆã° Babel ã‚’ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ãŸã“ã¨ãªã‹ã£ãŸãªã¨æ€ã£ã¦ã¡ã‚ƒã‚“ã¨å‹‰å¼·ã—ã¦ã¿ãŸã£ã¦è¨€ã†è©±ã§ã™ã€‚
ã¤ã¾ã‚Š Babel ã‚’ãƒãƒªã§ä½¿ã£ã¦ãŸã“ã¨ã«ãªã‚‹ã®ã§ã™ãŒã€è‡ªåˆ†ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’å§‹ã‚ãŸã¨ãã¯ <a href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a> ãŒã™ã§ã«å­˜åœ¨ã—ã¦ãŠã‚Šã€ãã‚Œã‚’ä½¿ã£ã¦ã„ã‚‹ã ã‘ã§å…¨ã¦ã‚’å€’ã›ã¦ã„ãŸã®ã§å‹‰å¼·ã™ã‚‹å¿…è¦ãŒãªã‹ã£ãŸã¨ã„ã†äº‹æƒ…ãŒã‚ã‚Šã¾ã™ã€‚</p>
<p>ãŸã ã€æµçŸ³ã«çŸ¥ã‚‰ãªã„ã¨è¨€ã£ã¦ã‚‚ãƒãƒƒãƒˆã‚µãƒ¼ãƒ•ã‚£ãƒ³ã—ã¦ã„ã‚‹ã¨ãªã‚“ã‚‰ã‹ã®æƒ…å ±ã®ã‚¤ãƒ³ãƒ—ãƒƒãƒˆã¯ã•ã‚Œã‚‹ã®ã§ã€</p>
<ul>
<li>Babel ã¯ ES6 -&gt; ES5 ã«å¤‰æ›ã™ã‚‹ï¼ˆã“ã‚Œã¯é–“é•ã£ãŸç†è§£ï¼‰</li>
<li>Babel ã¯ AST æ“ä½œã«ã‚ˆã£ã¦å¤‰æ›ã™ã‚‹</li>
<li>Babel ã¯ parse -&gt; traverse -&gt; generate ã—ã¦å¤‰æ›ã™ã‚‹</li>
</ul>
<p>ã¿ãŸã„ãªé †ç•ªã§å°‘ã—ãšã¤è§£åƒåº¦ã‚’ä¸Šã’ãªãŒã‚‰ç†è§£ã¯ã—ã¦ã„ã¾ã—ãŸã€‚
æœ€å¾Œã®ã€ã€ŒBabel ãŒ parse -&gt; traverse -&gt; generate ã—ã¦å¤‰æ›ã—ã¦ã„ã‚‹ã€ã¨è¨€ã†ã“ã¨ã«é–¢ã—ã¦ã¯ã€ <a href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/">Step-by-step guide for writing a custom babel transformation</a> ãªã©ã§çŸ¥ã£ã¦ã„ã¾ã—ãŸã€‚
ã—ã‹ã—ã€Œã»ã‚“ã¨ã†ã«ãã†ãªã®ã ã‚ã†ã‹ï¼Ÿã€ã¨ç¢ºè¨¼ãŒæŒã¦ã¾ã›ã‚“ã§ã—ãŸã€‚
ãªãœãªã‚‰<strong>å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‹ã‚‰ parse -&gt; traverse -&gt; generate ã—ã¦ã„ã‚‹è§£èª¬ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã‹ã£ãŸ</strong>ã‹ã‚‰ã§ã™ã€‚
ã¨ã„ã†ã‚ã‘ã§ã€ã¨ã‚Šã‚ãˆãšã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã§ã¿ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚</p>
<p>ä½•ã‹ã®æ­£è§£ã¨ç…§ã‚‰ã—åˆã‚ã›ã‚‰ã‚ŒãŸè¨³ã§ã¯ãªã„ã®ã§ã‚‚ã—é–“é•ã£ã¦ã„ã‚‹ã¨ã“ã‚ãŒã‚ã‚Šã¾ã—ãŸã‚‰ Issue ã‚„ Twitter ã§ã”æŒ‡æ‘˜ã„ãŸã ã‘ã‚‹ã¨å¹¸ã„ã§ã™ã€‚</p>
<h2>Babel ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ</h2>
<p>@babel/cli ã‹ã‚‰å®Ÿè¡Œã™ã‚‹ babel ã‚³ãƒãƒ³ãƒ‰ã¯</p>
<pre><code class="language-javascript:title=index.js">import parseArgv from &quot;./options&quot;
import dirCommand from &quot;./dir&quot;
import fileCommand from &quot;./file&quot;

const opts = parseArgv(process.argv)

if (opts) {
  // æ³¨ç›®: ã“ã“ã‹ã‚‰å…ˆã«é€²ã‚“ã§ã„ã
  const fn = opts.cliOptions.outDir ? dirCommand : fileCommand
  fn(opts).catch(err =&gt; {
    console.error(err)
    process.exitCode = 1
  })
} else {
  process.exitCode = 2
}
</code></pre>
<p>ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
ä¾¿å®œä¸Š bin/babel ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«å‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ã„ã¾ã™ãŒã€å®Ÿéš›ã«ã¯ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã¯ src/babel/index.js ã«å…¥ã£ã¦ã„ã¾ã™ã€‚</p>
<p>å¼•æ•°ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ãŸã¨ä»®å®šã—ã¦ã€fileCommand ã‚’èª­ã‚“ã§ã„ãã¾ã™ã€‚
ãã—ã¦ãã®é–¢æ•°ã¯æ¬¡ã®é€šã‚Šã§ã™ã€‚</p>
<pre><code class="language-javascript:title=file.js">export default async function({
  cliOptions,
  babelOptions,
}: CmdOptions): Promise&lt;void&gt; {
  // ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«å¾Œã®çµæœã‚’å‡ºåŠ›
  function output(fileResults: Array&lt;string&gt;): void {
    ...
    if (cliOptions.outFile) {
      ...
      fs.writeFileSync(mapLoc, JSON.stringify(result.map));
      ...
    } else {
      ...
      process.stdout.write(result.code + &quot;\n&quot;);
    }
  }

  async function walk(filenames: Array&lt;string&gt;): Promise&lt;void&gt; {
    ...
    const results = await Promise.all(
      _filenames.map(async function(filename: string): Promise&lt;Object&gt; {
        ...

        try {
          // æ³¨ç›®: ã“ã“ã‹ã‚‰å…ˆã«é€²ã‚“ã§ã„ã
          return await util.compile(
            filename,
            defaults(
              {
                sourceFileName: sourceFilename,
                sourceMaps:
                  babelOptions.sourceMaps === &quot;inline&quot;
                    ? true
                    : babelOptions.sourceMaps,
              },
              babelOptions,
            ),
          );
        } catch (err) {
          ...
      }),
    );

    output(results);
  }


  async function files(filenames: Array&lt;string&gt;): Promise&lt;void&gt; {
    ...
    await walk(filenames);
    ...
  }

  // å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†
  if (cliOptions.filenames.length) {
    await files(cliOptions.filenames);
  } else {
    await stdin();
  }
}

</code></pre>
<p>ã¤ã¾ã‚Šã¯ å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ walk ã—ã¦ compile ã—ãŸçµæœã‚’å‡ºåŠ›ã—ã¦ã„ã¾ã™ã€‚
ãã® compile ã‚’æ‹…å½“ã—ã¦ã„ã‚‹é–¢æ•°ãŒ <code>util.compile(fileName, ...)</code> ã§ã™ã€‚
å¤‰æ›å‡¦ç†ã‚’è¿½ã„ãŸã„ã®ã§ã“ã®é–¢æ•°ã‚’è¦‹ã¦ã¿ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=util.js">import * as babel from &quot;@babel/core&quot;;

export function compile(
  filename: string,
  opts: Object | Function,
): Promise&lt;Object&gt; {
  ...
  return new Promise((resolve, reject) =&gt; {
    // æ³¨ç›®: ã“ã“ã‹ã‚‰å…ˆã«é€²ã‚“ã§ã„ãã€@babel/coreå´ã«å‡¦ç†ãŒç§»ã‚‹
    babel.transformFile(filename, opts, (err, result) =&gt; {
      ...
    });
  });
}
</code></pre>
<p><a href="https://www.npmjs.com/package/@babel/core">@babel/core</a> ã® <code>babel.transformFile()</code> ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚
ã©ã†ã‚„ã‚‰@babel/core ã® transformFile ãŒå¤‰æ›å‡¦ç†ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã«ã«ãªã‚‹ã‚ˆã†ã§ã™ã€‚</p>
<h2>babel/core ã® transformFile ã®å…¨ä½“åƒ</h2>
<p><a href="https://www.npmjs.com/package/@babel/core">@babel/core</a> ã® transformFile ã‚’èª­ã¿é€²ã‚ã‚‹ã¨ <strong>run</strong> ã¨è¨€ã†é–¢æ•°ã«å‡ºä¼šã„ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=transform-file.js">// @flow
import {
  run,
  type FileResult,
  type FileResultCallback,
} from &quot;./transformation&quot;;
...

const transformFileRunner = gensync&lt;[string, ?InputOptions], FileResult | null&gt;(
  function*(filename, opts) {
    const options = { ...opts, filename };

    const config: ResolvedConfig | null = yield* loadConfig(options);
    if (config === null) return null;

    const code = yield* fs.readFile(filename, &quot;utf8&quot;);
    // æ³¨ç›®: ã“ã“ã‹ã‚‰å…ˆã«é€²ã‚“ã§ã„ã
    return yield* run(config, code);
  },
);

export const transformFile: TransformFile = transformFileRunner.errback;
...
</code></pre>
<p>ã“ã® run ã‚’èª­ã‚“ã§ã¿ã¾ã—ã‚‡ã†ã€‚
ã“ã“ã«ã¯ã€normalizeFile ã¨ transformFile ã¨ generateCode ã¨ã„ã†å‡¦ç†ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=index.js">export function* run(
  config: ResolvedConfig,
  code: string,
  ast: ?(BabelNodeFile | BabelNodeProgram)
): Handler&lt;FileResult&gt; {
  // æ³¨ç›®
  const file = yield* normalizeFile(
    config.passes,
    normalizeOptions(config),
    code,
    ast
  )

  try {
    // æ³¨ç›®
    yield* transformFile(file, config.passes)
  } catch (e) {
    ...
  }

  try {
    if (opts.code !== false) {
      // æ³¨ç›®
      ;({ outputCode, outputMap } = generateCode(config.passes, file))
    }
  } catch (e) {
    ...
  }

  return result // ast ã‚„ code
}
</code></pre>
<p>çµæœã‹ã‚‰è¨€ã†ã¨ã€ã“ã‚ŒãŒãã‚Œãã‚Œ parse, traverse, generate ã«ã‚ãŸã‚Šã¾ã™ã€‚</p>
<h3>parse</h3>
<p>normalizeFile ã‚’è¦—ãã¨ File ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=index.js">export default function* normalizeFile(
  pluginPasses: PluginPasses,
  options: Object,
  code: string,
  ast: ?(BabelNodeFile | BabelNodeProgram)
): Handler&lt;File&gt; {
  code = `${code || &quot;&quot;}`

  if (ast) {
    if (ast.type === &quot;Program&quot;) {
      ast = t.file(ast, [], [])
    }
    ...
  } else {
    // æ³¨ç›®
    ast = yield* parser(pluginPasses, options, code)
  }

  ...

  // æ³¨ç›®
  return new File(options, {
    code,
    ast,
    inputMap,
  })
}
</code></pre>
<p>ã“ã“ã§è¿”ã•ã‚Œã‚‹ File ã¯æ¬¡ã®ã‚ˆã†ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ class ã§ã™ã€‚</p>
<pre><code class="language-js">export default class File {
  _map: Map&lt;any, any&gt; = new Map();
  opts: Object;
  declarations: Object = {};
  path: NodePath = null;
  ast: Object = {};
  scope: Scope;
  metadata: {} = {};
  code: string = &quot;&quot;;
  inputMap: Object | null = null;

  ...
}
</code></pre>
<p>ast æƒ…å ±ã‚’å«ã‚ã¦è¿”ã—ã¦ã„ã¾ã™ã€‚
ã¤ã¾ã‚Š parse ã‚’ã—ã¦ã„ã¾ã™ã€‚
å®Ÿéš› normalize ã®ä¸­ã«ã‚ã‚‹ parser é–¢æ•°ã¯æ¬¡ã®é€šã‚Šã§ã™ã€‚</p>
<pre><code class="language-js">...
import { parse } from &quot;@babel/parser&quot;

...

export default function* parser(
  pluginPasses: PluginPasses,
  { parserOpts, highlightCode = true, filename = &quot;unknown&quot; }: Object,
  code: string
): Handler&lt;ParseResult&gt; {
  try {
    ...
    const ast = parserOverride(code, parserOpts, parse)
    ...
    if (results.length === 0) {
      // æ³¨ç›®
      return parse(code, parserOpts)
    } else if (results.length === 1) {
      ...
  } catch (err) {
    ...
  }
}
</code></pre>
<p><a href="https://github.com/babel/babel/tree/master/packages/babel-parser">@babel/parser</a> ã‚’ä½¿ã£ã¦ parse ã—ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚</p>
<h3>traverse</h3>
<p>ã•ã‚‰ã« run ã‚’èª­ã¿é€²ã‚ã¦ã„ãã¨, <code>yield* transformFile(file, config.passes)</code> ã¨ã„ã†ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚
traverse ã—ã¦ãã†ãªé›°å›²æ°—ãŒã‚ã‚‹ã®ã§èª­ã‚“ã§ã¿ã¾ã—ã‚‡ã†ã€‚
transformFile ã¯ã“ã®ã‚ˆã†ãªé–¢æ•°ã§ã™ã€‚</p>
<pre><code class="language-javascript:title=transformation/index.js">function* transformFile(file: File, pluginPasses: PluginPasses): Handler&lt;void&gt; {
  ...
  const visitors = [];
  for (const plugin of pluginPairs.concat([loadBlockHoistPlugin()])) {
    ...
    visitors.push(plugin.visitor);
  }
  ...

  const visitor = traverse.visitors.merge(
    visitors,
    passes,
    file.opts.wrapPluginVisitorMethod
  )
  traverse(file.ast, visitor, file.scope)

  for (const [plugin, pass] of passPairs) {
    const fn = plugin.post
    if (fn) {
      const result = fn.call(pass, file)
      ...
    }
  }
}
</code></pre>
<p>ã„ã¾ã—ãŸ <code>traverse(file.ast, visitor, file.scope);</code>.
å…ˆã»ã©ä½œã£ãŸ File ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã® ast ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚
ã“ã® traverse ã®é–¢æ•°ã¯ <a href="https://babeljs.io/docs/en/babel-traverse">@babel/traverse</a> ã‹ã‚‰ import ã—ãŸé–¢æ•°ã§ã™ã€‚
traverse é–¢æ•°ã« ast ã¨ plugin(visitors ã¨ã„ã†é…åˆ—ã«è©°ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹)ã‚’æ¸¡ã—ã¦å®Ÿè¡Œã—ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚
ã¤ã¾ã‚Š Babel ãŒ traverse ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã—ãŸã€‚</p>
<h3>generate</h3>
<p>ã•ã‚‰ã« run ã‚’èª­ã¿é€²ã‚ã¦ã„ãã¨, <code>generateCode(config.passes, file))</code> ã¨ã„ã†ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=transformation/file/generate.js">import generate from &quot;@babel/generator&quot;;

export default function generateCode(
  pluginPasses: PluginPasses,
  file: File
): {
  outputCode: string,
  outputMap: SourceMap | null,
} {
  ...
  let result;
  if (results.length === 0) {
    result = generate(ast, opts.generatorOpts, code);
  } else if (results.length === 1) {
    ...
  }

  return { outputCode, outputMap };
}
</code></pre>
<p>generate ã¯ <a href="https://github.com/babel/babel/tree/master/packages/babel-generator">@babel/generator</a> ã®é–¢æ•°ã§ã™ã€‚
ã“ã‚Œã¯ 'Turns an AST into code.' ã¨ã‚ã‚Šã€AST ã‚’ Code ã«æˆ»ã™é–¢æ•°ã§ã™ã€‚
ã¤ã¾ã‚Š AST -&gt; Code ã‚’ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã—ãŸã€‚</p>
<h2>æ¤œè¨¼çµæœ</h2>
<p>ã„ã‹ãŒã§ã—ãŸã‹ã€‚å™‚é€šã‚Š parse =&gt; traverse =&gt; generate ã—ã¦ã„ã¾ã—ãŸã€‚
Babel ã¯å„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«åˆ†ã‘ã¦ãã‚Œã‚‰ã®å‡¦ç†ã‚’è¡Œã£ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚
<a href="https://babeljs.io/docs/en/babel-cli">@babel/cli</a> -&gt; <a href="https://www.npmjs.com/package/@babel/core">@babel/core</a> -&gt; <a href="https://github.com/babel/babel/tree/master/packages/babel-parser">@babel/parser</a> -&gt; <a href="https://babeljs.io/docs/en/babel-traverse">@babel/traverse</a> -&gt; <a href="https://github.com/babel/babel/tree/master/packages/babel-generator">@babel/generator</a> ã¨ã„ã†é †ç•ªã§å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚
ãã®ãŸã‚ Babel ã¯ parse -&gt; traverse -&gt; generate ã—ã¦å¤‰æ›ã—ã¦ã„ã‚‹ã¨è¨€ãˆã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚</p>
<p><img src="tree.png" alt="Babelã®å¤‰æ›ã®ä»•çµ„ã¿" /></p>
<h2>å°ã•ã„ã‚³ãƒ¼ãƒ‰ã§æ¤œè¨¼ã—ã¦ã¿ã‚‹</h2>
<p>ãã‚Œãã‚Œãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ã¦ parse -&gt; traverse -&gt; generate ã—ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã—ãŸã€‚
ã—ã‹ã—ã“ã‚Œã ã¨ã‚¤ãƒã‚¤ãƒå®Ÿæ„ŸãŒæ¹§ã‹ãªã„ã¨æ€ã„ã¾ã™ã®ã§ã€ã‚ˆã‚Šè©³ç´°ã«å°ã•ã„ã‚³ãƒ¼ãƒ‰ã§å®Ÿè·µã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚</p>
<p>ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ç”¨æ„ã—ã¾ã™ã€‚</p>
<pre><code class="language-js">const parser = require(&quot;@babel/parser&quot;)
const traverse = require(&quot;@babel/traverse&quot;)
const generate = require(&quot;@babel/generator&quot;)

const code = &quot;const n = 1&quot;

// parse the code -&gt; ast
const ast = parser.parse(code)

// transform the ast
traverse.default(ast, {
  enter(path) {
    // in this example change all the variable `n` to `x`
    if (path.isIdentifier({ name: &quot;n&quot; })) {
      path.node.name = &quot;x&quot;
    }
  },
})

// generate code &lt;- ast
const output = generate.default(ast, code)
console.log(output.code) // 'const x = 1;'
</code></pre>
<p>ã“ã®ã‚³ãƒ¼ãƒ‰ã¯åºç›¤ã§ç´¹ä»‹ã—ãŸ <a href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/">Step-by-step guide for writing a custom babel transformation</a> ã«ã‚ã‚‹ã‚‚ã®ã§ã™ã€‚
ã“ã‚Œã¯ n ã‚’ x ã§ç½®ãæ›ãˆã‚‹å‡¦ç†ã‚’ babel ã§å®Ÿè¡Œã—ãŸã‚‚ã®ã§ã™ã€‚
ã„ã‚ã° @babel/core ã®ä¸­ã‚’å°ã•ãåˆ‡ã‚Šå‡ºã—ã¦ããŸã‚‚ã®ã§ã™ã€‚
ã“ã®å‡¦ç†ã‚’ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¸­ã‚’è¿½ã„ãªãŒã‚‰ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
<h3>parse</h3>
<p><code>parser.parse</code> ã®ä¸­èº«ã¯ã“ã®ã‚ˆã†ãªé–¢æ•°ã§ã™ã€‚</p>
<pre><code class="language-javascript:title=index.js">export function parse(input: string, options?: Options): File {
  if (options?.sourceType === &quot;unambiguous&quot;) {
    ...
    try {
      options.sourceType = &quot;module&quot;;
      const parser = getParser(options, input);
      const ast = parser.parse();
      ...
      return ast;
    } catch (moduleError) {
      ...
  } else {
    return getParser(options, input).parse();
  }
}
</code></pre>
<p>getParser ã®å…ˆã‚’è¿½ã£ã¦ã„ãã¨ nextToken ã‚„ lookahead ã¨ã„ã£ãŸå‡¦ç†ãŒã¿ã‚‰ã‚Œã‚‹ã¨æ€ã„ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=tokenizer/index.js">lookahead(): State {
  const old = this.state;
  this.state = old.clone(true);

  this.isLookahead = true;
  this.next();
  this.isLookahead = false;

  const curr = this.state;
  this.state = old;
  return curr;
}

nextTokenStart(): number {
  const thisTokEnd = this.state.pos;
  skipWhiteSpace.lastIndex = thisTokEnd;
  const skip = skipWhiteSpace.exec(this.input);
  // $FlowIgnore: The skipWhiteSpace ensures to match any string
  return thisTokEnd + skip[0].length;
}
</code></pre>
<p>ç¾åœ¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’èª­ã¿é€²ã‚ã¦ã„ã‚‹ä½ç½®ã€æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½ç½®ã€å…ˆèª­ã¿ã—ãŸæ–‡å­—ã‚’ç®¡ç†ã—ãªãŒã‚‰å®Ÿè¡Œã¨ã„ã£ãŸå‡¦ç†ãŒè¦‹ãˆã‚‹ã®ã§ã€å­—å¥è§£æã—ã¦ã„ã‚‹é›°å›²æ°—ãŒç¢ºèªã§ãã¾ã™ã€‚</p>
<p>ã¾ãŸ</p>
<pre><code class="language-js">parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
  ...
  const stmt = this.parseStatement(null, topLevel);
  ...
  body.push(stmt);
}
</code></pre>
<p>ãªã©ã®ã‚ˆã†ã«æ–‡ã‚’ parse ã—ã¦æ§‹ç¯‰å¯¾è±¡ã« push ã™ã‚‹ãªã©æ§‹æ–‡è§£æã—ã¦ã„ã‚‹é›°å›²æ°—ã‚‚æ„Ÿã˜ã‚‰ã‚Œã¾ã™ã€‚</p>
<p>å®Ÿéš› ã“ã®ã‚ˆã†ã« logger ã‚’ã—ã‹ã‘ã¦</p>
<pre><code class="language-js">const ast = parser.parse(code)
console.log(ast)
</code></pre>
<p>parse ã®çµæœã‚’å‡ºåŠ›ã™ã‚‹ã¨</p>
<pre><code class="language-sh">&gt; node index.js
Node {
  type: 'File',
  start: 0,
  end: 11,
  loc: SourceLocation {
    start: Position { line: 1, column: 0 },
    end: Position { line: 1, column: 11 }
  },
  errors: [],
  program: Node {
    type: 'Program',
    start: 0,
    end: 11,
    loc: SourceLocation { start: [Position], end: [Position] },
    sourceType: 'script',
    interpreter: null,
    body: [ [Node] ],
    directives: []
  },
  comments: []
}
</code></pre>
<p>ã¨è¨€ã†é¢¨ã« AST ãŒæ§‹ç¯‰ã•ã‚Œã¦ã„ã‚‹ã®ãŒã‚ã‹ã‚Šã¾ã™ã€‚</p>
<h3>traverse</h3>
<p>@babel/traverse ã¯ã“ã®ã‚ˆã†ã«èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<blockquote>
<p>The Babel Traverse module maintains the overall tree state, and is responsible for replacing, removing, and adding nodes.</p>
<p>FYI: https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#babel-traverse</p>
</blockquote>
<p>è¨€ã‚ã° AST ãƒãƒ¼ãƒ‰ã‚’æ“ä½œã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚
ã“ã® traverse é–¢æ•°ãŒã©ã®ã‚ˆã†ã«å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã¿ã¦ã„ãã¾ã—ã‚‡ã†ã€‚</p>
<pre><code class="language-js">export default function traverse(
  parent: Object | Array&lt;Object&gt;,
  opts?: Object,
  scope?: Object,
  state: Object,
  parentPath: Object,
) {
  ...
  traverse.node(parent, opts, scope, state, parentPath);
}

...

traverse.node = function(
  node: Object,
  opts: Object,
  scope: Object,
  state: Object,
  parentPath: Object,
  skipKeys?,
) {
  ...
  const context = new TraversalContext(scope, opts, state, parentPath);
  for (const key of keys) {
    if (skipKeys &amp;&amp; skipKeys[key]) continue;
    // NOTE: ã“ã“ã‹ã‚‰èª­ã¿é€²ã‚ã‚‹
    if (context.visit(node, key)) return;
  }
};
</code></pre>
<p>explode ã¨ node ã¨ã„ã†é–¢æ•°ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚</p>
<p>ã“ã® <code>context.visit(node, key)</code> ãŒ AST ã‚’è¾¿ã£ã¦å‡¦ç†ã‚’ã™ã‚‹æœ¬ä½“ã§ã™ã€‚
ã•ã‚‰ã«ãã“ã‹ã‚‰è¿½ã£ã¦ã„ãã¨ context ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-js">visitQueue(queue: Array&lt;NodePath&gt;) {
    ...

    // visit the queue
    for (const path of queue) {
      ...

      // NOTE: ã“ã“ã‹ã‚‰èª­ã¿é€²ã‚ã‚‹
      if (path.visit()) {
        stop = true;
        break;
      }
      ...
    }

    return stop;
  }
</code></pre>
<p>å®Ÿéš›ã«ã¯ AST ã‚’è¾¿ã‚ŠãªãŒã‚‰ NodePath ã¨ã„ã†å½¢å¼ã«å¤‰æ›ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ queue ã«è©°ã‚è¾¼ã‚“ã§ã„ãã€ãã® queue ã‚’ç®¡ç†ã—ãªãŒã‚‰ AST ã‚’è¾¿ã‚Šã¾ã™ã€‚</p>
<p>ã“ã® <code>path.visit()</code> ã¯ Mixin ã•ã‚ŒãŸ NodePath_context ã®æŒã¡ç‰©ã§ã™ã€‚
<strong>Editor ã®ã‚³ãƒ¼ãƒ‰ã‚¸ãƒ£ãƒ³ãƒ—ã§ã¯è¦‹ã¤ã‘ã‚‰ã‚Œãªã„ã®ã§æ³¨æ„ã—ã¾ã—ã‚‡ã†ã€‚</strong></p>
<pre><code class="language-js">Object.assign(
  NodePath.prototype,
  NodePath_ancestry,
  NodePath_inference,
  NodePath_replacement,
  NodePath_evaluation,
  NodePath_conversion,
  NodePath_introspection,
  NodePath_context,
  NodePath_removal,
  NodePath_modification,
  NodePath_family,
  NodePath_comments
)
</code></pre>
<p>ã•ã‚ã‚´ãƒ¼ãƒ«ã¯è¿‘ã¥ã„ã¦ãã¾ã—ãŸã€‚
visit ã®ä¸­ã¯ã“ã†ãªã£ã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=lib/context.js">export function visit(): boolean {
  ...

  // NOTE: ã“ã“ã‹ã‚‰èª­ã¿é€²ã‚ã‚‹
  if (this.shouldSkip || this.call(&quot;enter&quot;) || this.shouldSkip) {
    this.debug(&quot;Skip...&quot;);
    return this.shouldStop;
  }

  ...

  this.call(&quot;exit&quot;);

  return this.shouldStop;
}
</code></pre>
<p><code>this.call(&quot;enter&quot;)</code> ã¨ <code>this.call(&quot;exit&quot;)</code> ã¯ enter ã¨ exit é–¢æ•°ã‚’ call ã—ã¦ã„ã‚‹é›°å›²æ°—ãŒã‚ã‚Šã¾ã™ã€‚
ã¾ã‚‹ã§ AST ãƒãƒ¼ãƒ‰ã«å…¥ã£ãŸæ™‚ã¨å‡ºã¦ã„ãæ™‚ã«å®Ÿè¡Œã™ã‚‹é–¢æ•°ã®ã‚ˆã†ã«ãƒ»ãƒ»ãƒ»
è¿½ã£ã¦ã¿ã¾ã—ã‚‡ã†ï¼</p>
<pre><code class="language-js">export function call(key): boolean {
  ...
  if (this.node) {
    // NOTE: ã“ã“ã‹ã‚‰èª­ã¿é€²ã‚ã‚‹
    if (this._call(opts[key])) return true;
  }
 ...
  return false;
}

export function _call(fns?: Array&lt;Function&gt;): boolean {
  ...
  const ret = fn.call(this.state, this, this.state);
  ...
}
</code></pre>
<p>ã¯ã„å‘¼ã‚“ã§ã„ã¾ã—ãŸã€‚</p>
<p>ã“ã“ã§æ¤œè¨¼ã«ä½¿ã£ãŸã‚³ãƒ¼ãƒ‰ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚</p>
<pre><code class="language-javascript:title=index.js">// transform the ast
traverse.default(ast, {
  enter(path) {
    // in this example change all the variable `n` to `x`
    if (path.isIdentifier({ name: &quot;n&quot; })) {
      path.node.name = &quot;x&quot;
    }
  },
})
</code></pre>
<p>call ã•ã‚Œã‚‹é–¢æ•°ã¯ <code>this._call(opts[key])</code>ã¨ã—ã¦å‘¼ã°ã‚Œã¦ã„ãŸã‚ã‘ã§ã™ãŒã€ã“ã® opts ã«ã¯æ¤œè¨¼ã‚³ãƒ¼ãƒ‰ä¸Šã ã¨ <code>enter(path) {}</code>ã«è©²å½“ã—ã¾ã™ã€‚</p>
<p>ãã—ã¦ã“ã‚Œã¯ <code>babel-plugin</code> ã®å‡¦ç†ã‚’æµã—è¾¼ã‚ã‚‹ä»•çµ„ã¿ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚
å®Ÿã¯ <code>traverse</code> é–¢æ•°ã®ç¬¬äºŒå¼•æ•°ã¯ã“ã® plugin ã«æ›¸ã„ãŸå‡¦ç†ã®å¡Šã§ã™ã€‚
ã“ã®ä¸­ã§ AST ã‚’æ›¸ãæ›ãˆã‚‹å‡¦ç†ã‚’å…¥ã‚Œã¾ã™ã€‚
å…ˆã®ä¾‹ã ã¨ <code>path.node.name = &quot;x&quot;</code> ã¨ã„ã†é¢¨ã«å¤‰æ•°åã‚’ x ã«æ›¸ãæ›ãˆã¦ã„ã¾ã™ã€‚
ã¤ã¾ã‚Š <strong>traverse ã¯ AST ã‚’æ“ä½œã—ã¦ã„ã‚‹ã®ã§ã¯ãªãã€AST ã‚’æ“ä½œã™ã‚‹é–¢æ•°ã‚’å®Ÿè¡Œã—ã¦ã„ãŸ</strong>è¨³ã§ã™ã€‚
@babel/traverse ã‚’å…¨éƒ¨èª­ã¿ãã£ãŸã‚ã‘ã§ã¯ãªã„ã®ã§ç¢ºè¨¼ã¯æŒã¦ãªã„ã¨ã“ã‚ã‚‚ã‚ã‚‹ã®ã§ã™ãŒã€ä»Šã®ã¨ã“ã‚ã¯ãã®ã‚ˆã†ãªç†è§£ã§ã™ã€‚</p>
<h3>generate</h3>
<p>@babel/generate ã®ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆã¯ã“ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-js">import SourceMap from &quot;./source-map&quot;;
import Printer, { type Format } from &quot;./printer&quot;;

class Generator extends Printer {
  ...

  constructor(ast, opts = {}, code) {
    ...
    this.ast = ast;
  }

  generate() {
    return super.generate(this.ast);
  }
}

...

export default function(ast: Object, opts: Object, code: string): Object {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}
</code></pre>
<p><code>return super.generate(this.ast);</code> ã¨ã‚ã‚‹ã®ã§ super class ã§ã‚ã‚‹ Printer ã‚’ç¢ºèªã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
<pre><code class="language-javascript:title=printer.js">generate(ast) {
  this.print(ast);
  this._maybeAddAuxComment();

  return this._buf.get();
}
</code></pre>
<p>ã“ã® print <code>token</code> ã‚„ <code>printMethod</code> ãªã©ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-js">print(node, parent) {
    ...
    if (needsParens) this.token(&quot;(&quot;);

    this._printLeadingComments(node);

    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
    this.withSource(&quot;start&quot;, loc, () =&gt; {
      printMethod.call(this, node, parent);
    });

    this._printTrailingComments(node);

    if (needsParens) this.token(&quot;)&quot;);

    ...
  }

   token(str: string): void {
   ...
    this._append(str);
  }
</code></pre>
<p>printMethod ã¯ã€AST Node ã®ç¨®é¡ã«å¿œã˜ã¦ã€indent, dedent, semicolon, rightBrace, ... ã¨ã„ã£ãŸå‡¦ç†ã‚’å®Ÿè¡Œã—ã¦ã„ãã¾ã™ã€‚
ã©ã†ã„ã†å‡¦ç†ãŒã•ã‚Œã‚‹ã‹ã¯ Printer ã‚¯ãƒ©ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-js">indent(): void {
  if (this.format.compact || this.format.concise) return;
  this._indent++;
}

dedent(): void {
  if (this.format.compact || this.format.concise) return;
  this._indent--;
}
</code></pre>
<p>ãã—ã¦ã“ã‚Œã‚‰ã®é–¢æ•°ã¯ _append ã¨ã„ã†å‡¦ç†ã‚’å‘¼ã³å‡ºã—ã€å‡¦ç†çµæœã‚’ <code>this._buf.append(str);</code> ã§ buffer ã« å…¥ã‚Œã¦ã„ãã¾ã™ã€‚
ãã—ã¦ã“ã® buffer ãŒ printer.js ã§ <code>return this._buf.get();</code> ã•ã‚Œã¦å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚</p>
<p>å®Ÿé¨“ç”¨ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€generate ã« AST ä»¥å¤–ã«ã‚‚ code ã‚’æ¸¡ã—ã¦ã„ã¾ã™ãŒã€</p>
<pre><code class="language-javascript:title=index.js">const code = &quot;const n = 1&quot;

...

// generate code &lt;- ast
const output = generate.default(ast, code)
</code></pre>
<p>ã“ã‚Œã¯ source map ç”¨ã«æ¸¡ã—ã¦ã„ã‚‹ã ã‘ã§ã€code ã®ç”Ÿæˆã¯ AST ã®æƒ…å ±ã ã‘ã‚ã‚Œã°å¯èƒ½ã§ã™ã€‚
ã“ã®æ™‚ç‚¹ã§ traverse ã«ã‚ˆã£ã¦ AST ã‚’å¤‰æ›ã—ã¦ã„ã‚‹ã¯ãšãªã®ã§ã€AST ã ã‘æ¸¡ã›ã°å¤‰æ›å¾Œã®ã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã§ãã¾ã™ã€‚</p>
<h2>Babel ã¯ ES6 =&gt; ES5 ã«å¤‰æ›ã™ã‚‹ã¨ã„ã†èª¤è§£</h2>
<p>ã•ã¦ã•ã¦ã€æœ€åˆã«åƒ•ã¯ ES6 =&gt; ES5 ã«å¤‰æ›ã™ã‚‹é­”æ³•ã®ç®±ã¨å‹˜é•ã„ã—ã¦ã„ã‚‹ã¨æ›¸ã„ã¦ã„ã¾ã—ãŸã€‚
åƒ•ã®å‘¨ã‚Šã«ã‚‚åŒã˜å‹˜é•ã„ã—ã¦ã„ã‚‹äººã«å‡ºä¼šã£ãŸã“ã¨ãŒã‚ã‚‹ã®ã§ã¤ã„ã§ã«è¨€åŠã—ãŸã„ãªã¨æ€ã„ã¾ã™ã€‚</p>
<p>ä¾‹ãˆã°</p>
<pre><code class="language-javascript:title=index.js">const hoge = () =&gt; {}
</code></pre>
<p>ã¨ã„ã†é–¢æ•°ã‚’ babel ã§å¤‰æ›ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
<pre><code class="language-sh">npm i @babel/core @babel/cli
</code></pre>
<p>ã“ã®å¤‰æ›çµæœã¯ã©ã†ãªã‚‹ã§ã—ã‚‡ã†ã‹ï¼Ÿ
ES5 ã«ãªã‚‹ã¯ãšã§ã™ã‚ˆã­ï¼ãƒ»ãƒ»ãƒ»ãªã‚Šã¾ã›ã‚“ ğŸ˜­</p>
<pre><code class="language-bash">$ npx babel index.js
&gt; const hoge = () =&gt; {};
</code></pre>
<p>ã“ã†ãªã‚Šã¾ã™ã€‚</p>
<p>ã¤ã¾ã‚Šä½•ã‚‚ AST æ“ä½œãŒã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã“ã“ã§ traverse ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚
traverse ã®ãŸã‚ã«ã¯ enter ã¨ exit ãŒå®šç¾©ã•ã‚ŒãŸä½•ã‹ãŒå¿…è¦ãªã‚“ã§ã™ã‚ˆã­ã€‚
ãã‚Œã¯è‡ªä½œé–¢æ•°ã ã£ãŸã‚Š babel-plugin ã ã£ãŸã‚Šã—ã¾ã™ã€‚</p>
<p>ä¾‹ãˆã°ã€<a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-arrow-functions">@babel/plugin-transform-arrow-functions</a>ãªã©ãŒå¿…è¦ã§ã™ã€‚</p>
<p>è©¦ã—ã«ã“ã® plugin ã‚’å…¥ã‚Œã¦ babel ã‚’å®Ÿè¡Œã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
<pre><code class="language-bash">$ npm i -D @babel/plugin-transform-arrow-functions

$ echo '{ &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;] }' &gt; .babelrc

$ &gt; npx babel index.js
const hoge = function () {};
</code></pre>
<p>ãã¡ã‚“ã¨ function ã«å¤‰æ›ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã—ãŸã€‚</p>
<p>@babel/plugin-transform-arrow-functions ã®ä¸­ã¯ã“ã†ãªã£ã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-javascript:title=index.js">import { declare } from &quot;@babel/helper-plugin-utils&quot;
import type NodePath from &quot;@babel/traverse&quot;

export default declare((api, options) =&gt; {
  api.assertVersion(7)

  const { spec } = options
  return {
    name: &quot;transform-arrow-functions&quot;,

    visitor: {
      ArrowFunctionExpression(
        path: NodePath&lt;BabelNodeArrowFunctionExpression&gt;
      ) {
        if (!path.isArrowFunctionExpression()) return

        path.arrowFunctionToExpression({
          allowInsertArrow: false,
          specCompliant: !!spec,
        })
      },
    },
  }
})
</code></pre>
<p>ã“ã“ã§ã¯ visitor ã¨ã‚ã‚Š enter ã‚‚ exit ã‚‚å‡ºã¦ãã¦ãªã„ã®ã§ã™ãŒã€@babel/traverse ãŒå†…éƒ¨ã§ enter ãªã©ã‚’æŒã¤ã‚ˆã†ã«å¤‰æ›ã—ã¦ã„ã‚‹ãŸã‚å¤§ä¸ˆå¤«ã§ã™ã€‚
enter ã¨ exit ã‚’æŒã¤ã“ã¨ã¯ travese ã® explode ãŒç¢ºè¨¼ã—ã¦ãã‚Œã¦ã€ãã®ä¸­ã«ã¯ ensureEntranceObjects(visitor) ã¨ã„ã†é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚</p>
<p>ã“ã®é–¢æ•°ã¯</p>
<pre><code class="language-javascript:title=visitors.js">function ensureEntranceObjects(obj) {
  for (const key of Object.keys(obj)) {
    if (shouldIgnoreKey(key)) continue

    const fns = obj[key]
    if (typeof fns === &quot;function&quot;) {
      obj[key] = { enter: fns }
    }
  }
}
</code></pre>
<p>ã¨ã‚ã‚Šã€visitor é–¢æ•°ã‚’ <code>obj[key] = { enter: fns }</code> ã¨å®šç¾©ã—ç›´ã—ã¦ãã‚Œã¾ã™ã€‚
explode é–¢æ•°ã¯ä»–ã«ã‚‚ã„ã‚ã‚“ãªå½¢ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ traverse å†…ã§æ‰±ãˆã‚‹ã‚ˆã†ãªæ­£è¦åŒ–ã‚’ã—ã¦ãã‚Œã¦ã„ã¾ã™ã€‚
é–¢æ•°ã«ã¯ã“ã®ã‚ˆã†ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<pre><code>/**
 * explode() will take a visitor object with all of the various shorthands
 * that we support, and validates &amp; normalizes it into a common format, ready
 * to be used in traversal
 *
 * The various shorthands are:
 * * `Identifier() { ... }` -&gt; `Identifier: { enter() { ... } }`
 * * `&quot;Identifier|NumericLiteral&quot;: { ... }` -&gt; `Identifier: { ... }, NumericLiteral: { ... }`
 * * Aliases in `@babel/types`: e.g. `Property: { ... }` -&gt; `ObjectProperty: { ... }, ClassProperty: { ... }`
 *
 * Other normalizations are:
 * * Visitors of virtual types are wrapped, so that they are only visited when
 *   their dynamic check passes
 * * `enter` and `exit` functions are wrapped in arrays, to ease merging of
 *   visitors
 */
</code></pre>
<p>ã¤ã¾ã‚Š plugin ã« visitor ã‚’æ›¸ã„ã¦ãŠã‘ã°ã€enter ã¨ã—ã¦ traverse ãŒå®Ÿè¡Œã—ã¦ãã‚Œã¾ã™ã€‚</p>
<p>@babel/plugin-transform-arrow-functions ã‚’ä½¿ãˆã° traverse ã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚
å®Ÿéš›ã®ã¨ã“ã‚@babel/plugin-transform-arrow-functions ã‚’å…ˆã«èª­ã¿é€²ã‚ã¦ã„ãã¨</p>
<pre><code class="language-javascript:title=conversion.js">export function arrowFunctionToExpression({
  allowInsertArrow = true,
  specCompliant = false,
} = {}) {
  ..

  const thisBinding = hoistFunctionEnvironment(
    this,
    specCompliant,
    allowInsertArrow
  )

  this.ensureBlock()
  this.node.type = &quot;FunctionExpression&quot;
  ...
    this.get(&quot;body&quot;).unshiftContainer(
      &quot;body&quot;,
      t.expressionStatement(
        t.callExpression(this.hub.addHelper(&quot;newArrowCheck&quot;), [
          t.thisExpression(),
          checkBinding
            ? t.identifier(checkBinding.name)
            : t.identifier(thisBinding),
        ])
      )
    )

    this.replaceWith(
      t.callExpression(
        t.memberExpression(
          nameFunction(this, true) || this.node,
          t.identifier(&quot;bind&quot;)
        ),
        [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]
      )
    )
  }
}
</code></pre>
<p>ãŒå‘¼ã°ã‚Œã¦ãŠã‚Šã€arrow é–¢æ•°ã®ç‰¹å¾´ã§ã‚ã‚‹ this ã® bind ã‚’å¤‰æ›ã—ã¦ã„ã‚‹é›°å›²æ°—ã¯æ„Ÿã˜ã‚‰ã‚Œã¾ã™ã€‚
ã¤ã¾ã‚Šã“ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å…¥ã‚Œã¦ãŠãã¨ arrow é–¢æ•°ã®å¤‰æ›ãŒã§ãã‚‹ã‚ã‘ã§ã™ã€‚</p>
<p><strong>ã“ã®ã‚ˆã†ã« traverse ã¯ plugin ã‚’é©ç”¨ã—ã¦ãŠã‚Šã€é€†ã«ã“ã® plugin ãŒãªã‘ã‚Œã°ä½•ã‚‚ AST æ“ä½œãŒã•ã‚Œãªã„ã¨ã„ã†ã“ã¨ã§ã‚ã‚Šã€ãŸã  babel ã‚’å®Ÿè¡Œã™ã‚‹ã ã‘ã§ã¯ ES6 ã®æ§‹æ–‡ã‚’ ES5 ã®æ§‹æ–‡ã«ã™ã‚‹ã“ã¨ã¯ã§ããªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚</strong></p>
</div>
    <footer>
      <p>
        ã“ã®ã‚µã‚¤ãƒˆã§ã¯ Google
        Analyticsã§ã®è¨ˆæ¸¬ã®ãŸã‚ã€ã‚¯ãƒƒã‚­ãƒ¼ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚
      </p>

      <p>
        ã“ã®ã‚µã‚¤ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯<a
          href="https://github.com/sadnessOjisan/new-blog.ojisan.io"
          >ã“ã¡ã‚‰</a
        >ã€‚
      </p>
      <p>Â©ï¸ <a href="https://twitter.com/sadnessOjisan">sadnessOjisan</a></p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script>
      (function () {
        var webfont = document.getElementById("webfont");
        webfont.rel = "stylesheet";
      })();
    </script>
  </body>
</html>
